This is git.info, produced by Makeinfo version 3.12h from git.texinfo.

START-INFO-DIR-ENTRY
* GIT: (git).         GNU Interactive Tools
END-INFO-DIR-ENTRY

   GIT: A set of interactive tools, by Tudor Hulubei and Andrei Pitis.

   This file documents the GNU Interactive Tools package.

   Copyright (C) 1993-1998 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: git.info,  Node: Top,  Next: Introduction,  Up: (dir)

   `GIT' is a package containing basically a file system browser, a
process viewer/killer and a ASCII/HEX file viewer.  This is edition
2.9, for GNU Interactive Tools version 4.3.20.

* Menu:

* Introduction::                An introduction to GIT concepts.
* Distrib::                     How to get the latest GIT distribution.

* Description::                 How to use GIT.
* Customization::               How to customize GIT.
* Limitations::                 Known GIT limitations.
* Bugs::                        How to report a bug.
* Key Index::                   An item for each standard GIT key sequence.
* Command Index::               An item for each command name.
* Variable Index::              An item for each documented variable.
* Concept Index::               An item for each concept.


File: git.info,  Node: Introduction,  Next: Distrib,  Prev: Top,  Up: Top

Introduction
************

   `GIT' is a set of interactive tools.  It contains an extensible file
system browser, an ascii/hex file viewer, a process viewer/killer and
some other related utilities and shell scripts.  It can be used to
increase the speed and efficiency of most of the daily tasks such as
copying and moving files and directories, invoking editors, compressing
and uncompressing files, creating and expanding archives, compiling
programs, sending mail, etc.  It looks nice, has colors (if the standard
ANSI color sequences are supported) and is user-friendly.

   `GIT' runs on a wide variety of `UNIX' systems because it uses the
`GNU Autoconf' package to get system specific information.  Please
refer to the PLATFORMS file included in the standard distribution for a
detailed list of systems on which `GIT' has been tested.

   One of the main advantages of `GIT' is its flexibility.  It is not
limited to a given set of commands.  The configuration file can be
easily enhanced, allowing the user to add new commands or file
operations, depending on its needs or preferences.

   `GIT' also provides a shell like command prompt, just to make sure
that the entire power of the `UNIX' shell commands is still there.


File: git.info,  Node: Distrib,  Next: Key Index,  Prev: Introduction,  Up: Top

Distributing GNU Interactive Tools
**********************************

   `GIT' is "free software"; this means that everyone is free to use it
and free to redistribute it on certain conditions.  `GIT' is not in the
public domain; it is copyrighted and there are restrictions on its
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of `GIT'
that they might get from you.  The precise conditions are found in the
GNU General Public License that comes with `GIT' and also appears
following this section.

   The easiest way to get a copy of `GIT' is from someone else who has
it.  You need not ask for our permission to do so, or tell any one else;
just copy it.  If you have access to the Internet, you can get the
latest distribution version of `GIT' from host `ftp.gnu.org' using
anonymous login.  See the file `/pub/gnu/GETTING.GNU.SOFTWARE' on that
host to find out about your options for copying and which files to use.

   You may also receive `GNU Interactive Tools' when you buy a
computer.  Computer manufacturers are free to distribute copies on the
same terms that apply to everyone else.  These terms require them to
give you the full sources, including whatever changes they may have
made, and to permit you to redistribute the GNU Interactive Tools
received from them under the usual terms of the General Public License.
In other words, the program must be free for you when you get it, not
just free for the manufacturer.


File: git.info,  Node: Description,  Next: Customization,  Prev: Concept Index,  Up: Top

Using GNU Interactive Tools
***************************

   The `GIT' package contains three interactive programs and a few
additional utilities.  Here there is a description of each of them.

* Menu:

* git::                         A file system browser.
* gitps::                       A process viewer/killer.
* gitview::                     An ASCII/HEX file viewer.
* gitkeys::                     An utility for displaying key sequences.
* gitwipe::                     An utility for wiping files.
* gitmount::                    A script for mounting file systems.
* gitaction::                   A per file type action script.
* gitunpack::                   Unified archive unpacking.
* gitrgrep::                    A recursive grep script.


File: git.info,  Node: git,  Next: gitps,  Up: Description

The GIT file system browser
===========================

   `git' is a file system browser with some shell like features
designed to make your work much easier and much efficient.  It displays
one or two panels, each one containing a file system directory.  You can
browse the directory tree with the usual cursor keys, pressing `ENTER'
when you want to enter or leave a directory and `TAB' when you want to
change the panels.

   Under the two panels there is a shell like input line which you can
use to type normal shell commands.  The input line can handle an
unlimited number of characters and keeps a history of typed commands
(using the GNU history library).

   Under the input line there is a status bar.  You can see there the
status of the currently executed command, the warnings and errors and
you will be prompted if a decision has to be taken.

* Menu:

* Conventions::                 Key binding conventions.

* Command line::                The command line arguments.
* Modes::                       How panels can look like.
* Sorting::                     How files can be sorted in a panel.
* Moving::                      How to move the cursor in the panel.
* Selecting::                   How to select (mark) files in a panel.
* Isearch::                     How to search a file name in a panel.
* Input Line::                  How to use the input line.  Basic editing.
* Files::                       How to copy/move/delete/compress/... files.
* Directories::                 How to operate with directories.
* Compiling::                   How to compile programs.
* Mail::                        How to send/receive ascii/binary mail.
* Shell::                       How to start a sub-shell.
* Grep::                        How to use grep/recursive grep.
* Locking::                     How to lock your console.
* Refreshing::                  How to refresh the screen contents.
* Reseting::                    How to reset your terminal.
* Mounting::                    How to mount/unmount a file system.
* Sysinfo::                     How to get some useful system information.
* Environment::                 How to look at the environment variables.
* Processes::                   How to view/kill processes.
* Sync::                        How to synchronize your file systems.

* Documentation::               How to read documentation.

* Exit::                        How to exit GNU Interactive Tools.


File: git.info,  Node: Conventions,  Next: Command line,  Up: git

Key binding conventions
-----------------------

   `git' now follows a new, easy to remember, scheme to bind commands
on keys.  This is only a convention, if you define new key bindings you
may, or may not follow it.

   All the file commands start with `^C'.  This prefix can be followed
by some modifiers, in order to affect the default behavior of the given
command.  These modifiers are `b' and `r'.

   `b' - this modifier specifies that the command will run in
background:

     	^CM = CHMOD; chmod %s{New mode of %i: ,%m} %i;;;;y

defines a command that changes the current selected files mode in
foreground, while

     	^CbM = B-CHMOD; chmod %s{New mode of %i: ,%m} %i&;;;;y

defines a background command that does the same thing.

   `r' - this modifier specifies that the command will be run
recursively:

     	^CrM = R-CHMOD; chmod -R %s{New mode of %i: ,} %i;;;;y

defines a command that recursively changes the mode of the selected
entries.

   The `b' and `r' modifiers can be combined, the resulting command
running recursively and in background:

     	^CbrM = B-R-CHMOD; chmod -R %s{New mode of %i: ,} %i&;;;;y

   You should also note that for some commands (like `gzip') there is
no need for a non-recursive version.  Running `gzip' recursively on
files is harmless.  If there is a directory between these files, `gzip'
will recursively compress that directory, so you can use the same key
binding for recursively and non-recursively compressing.  In fact, it
is a matter of selecting files or directories.

   Unfortunately, we can't run `chmod' recursively trying to change the
mode of all the files in a directory to 0644 because that directory
might contain subdirectories and removing the execution permission from
them is a bad idea.  So, in this case, we need separate commands.


File: git.info,  Node: Command line,  Next: Modes,  Prev: Conventions,  Up: git

Command line
------------

   This is a brief description of the command line arguments.

`-h'         print this help message

`-v'         print the version number

`-i'         print the installation directory

`-c'         use ANSI colors

`-b'         don't use ANSI colors

`-l'         don't use the last screen character

`-p'         output final path at exit

   The `-p' option can be used to make git force bash (assuming that
you're using it as your shell) chdir to the last directory git was in
before quitting.  In order to do this, you need to invoke git using this
function (put it into your .profile):

     function g
     {
         git -p $ 3> /tmp/git.p.$$
     
         if test -s /tmp/git.p.$$; then
     	if test -d "`cat /tmp/git.p.$$`"; then
     	    cd "`cat /tmp/git.p.$$`"
     	else
     	    cd
     	fi
         fi
     
         rm -f /tmp/git.p.$$
     }

   This will not work if you suspend git.  Nothing bad will happen, just
the chdir will not be performed.


File: git.info,  Node: Modes,  Next: Sorting,  Prev: Command line,  Up: git

Panel modes
-----------

   `git' has three major modes of displaying the panels.  In the first
(default) mode, two panels are displayed, each one using half of the
screen.  In the second mode, only one panel uses the entire screen.  In
the third mode, only the status bar and the input line are displayed,
both panels being hidden.

   Briefly, a panel can use the entire screen or just half of it.  Even
when a panel is hidden, it still exists.

   Users can switch between these three major modes as needed:

`^X 0'
     Enlarges the other panel to use the entire screen.  It also changes the
     minor mode to `Enable all'.  The current panel will become
     invisible (`enlarge-other-panel').

`^X 1'
     Enlarges the current panel to use the entire screen.  It also changes
     the minor mode to `Enable all'.  The other panel will become
     invisible (`enlarge-panel').

`^X 2'
     Switches back to the two panel mode (`two-panel-mode').

`^O', `ESC o'
     Switches to the tty mode (no panels on the screen) (`tty-mode').

   Basically a panel displays the files and directories in a directory.
You can optionally specify some additional information about each entry
(file, directory, ...) to be displayed (a minor mode).

   When using the full screen mode, all the minor modes here can be
used.  In half screen mode, the `panel-enable-all' mode is not
available.

   These are the panel minor modes:

`ESC d o'
     Display the entry owner and group (`panel-enable-owner-group').

`ESC d d'
     Display the entry date and time (`panel-enable-date-time').

`ESC d s'
     Display the entry size (`panel-enable-size').

`ESC d m'
     Display the entry mode (`panel-enable-mode').

`ESC d f'
     Display the entry full name (`panel-enable-full-name').

`ESC d a'
     Display the entire information about file (`panel-enable-all').
     This mode is only available if the panel has been enlarged to use the
     entire screen with `enlarge-panel' or `enlarge-other-panel'
     (`panel-enable-all').

   There is also another way to change the panel minor modes:

`^]', `^[]'
     Switches to the next panel minor mode (`panel-enable-next-mode').


File: git.info,  Node: Sorting,  Next: Moving,  Prev: Modes,  Up: git

Sorting methods
---------------

   Entries in a panel can be sorted in different ways.  These are the
available options:

`ESC s n'
     Display the panel entries sorted by their names
     (`panel-sort-by-name').

`ESC s e'
     Display the panel entries sorted by their extensions
     (`panel-sort-by-extension').

`ESC s s'
     Display the panel entries sorted by their sizes
     (`panel-sort-by-size').

`ESC s d'
     Display the panel entries sorted by their `last modified' stamps
     (`panel-sort-by-date').

`ESC s m'
     Display the panel entries sorted by their modes
     (`panel-sort-by-mode').

`ESC s o i'
     Display the panel entries sorted by their owner ids
     (`panel-sort-by-owner-id').

`ESC s g i'
     Display the panel entries sorted by their group ids
     (`panel-sort-by-group-id').

`ESC s o n'
     Display the panel entries sorted by their owner names
     (`panel-sort-by-owner-name').

`ESC s g n'
     Display the panel entries sorted by their group names
     (`panel-sort-by-group-name').

   There is also another way to change the sort method:

`ESC s u'
     Switch to the next panel sort method (`panel-sort-next-method').


File: git.info,  Node: Moving,  Next: Selecting,  Prev: Sorting,  Up: git

Moving the cursor in the panel
------------------------------

   Moving the cursor in the panel is very easy.  If your keyboard has
arrows, use them.  If the arrow keys don't work (it might be due to a
badly configured TERM environment variable), you can use the Emacs
commands bindings as well.

`UP', `^P'
     Move the cursor vertically up one entry (`previous-line').

`DOWN', `^N'
     Move the cursor vertically down one entry (`next-line').

`HOME', `ESC <'
     Move the cursor on the first entry in the panel
     (`beginning-of-panel').

`END', `ESC >'
     Move the cursor on the last entry in the panel (`end-of-panel').

`PGUP', `ESC v'
     Move the cursor vertically down one page (`scroll-down').

`PGDOWN', `^V'
     Move the cursor vertically down one page (`scroll-up').

`ESC g'
     Scroll the panel entries to the left (`horizontal-scroll-left').

`ESC j'
     Scroll the panel entries to the right (`horizontal-scroll-right').

`^X P'
     In order to optimize the screen output, you can modify the scroll step
     (`set-scroll-step').  This is the number of lines to try scrolling
     a panel when the cursor moves out.  The `StartupScrollStep'
     specifies the initial scroll step, but using `set-scroll-step' you
     can dynamically change it.

`TAB', `^I', `^X o'
     Move the cursor in the other panel (`other-panel').

`^X P'
     Switch the two panels.  This command works even when `git' is not
     in the `two panels' mode (`switch-panels').


File: git.info,  Node: Selecting,  Next: Isearch,  Prev: Moving,  Up: git

Selecting files
---------------

`INS', `^T', `^X \', `^\'
     Toggle the `selected' flag of the current entry
     (`select-entry').

`^C s'
     Select (marks) all the files matching at least one pattern from a space
     separated list of shell patterns.  Spaces and \s are allowed in the
     patterns but they have to be escaped with a \.  The user will be
     prompted for a pattern to match against
     (`select-files-matching-pattern').

`^C u'
     Unselect (unmarks) all the files matching at least one pattern from a
     space separated list of shell patterns.  Spaces and \s are allowed in
     the patterns but they have to be escaped with a \.  The user will be
     prompted for a pattern to match against
     (`unselect-files-matching-pattern').

`ESC +'
     Select (marks) all the files having the same extension as the current
     file.  If the current file name doesn't have an extension or starts with
     a dot, no files are selected (`select-extension').

`ESC -'
     Unselect (unmarks) all the files having the same extension as the
     current file.  If the current file name doesn't have an extension or
     starts with a dot, no files are unselected (`unselect-extension').

   *Note Selecting Files::, for additional ways of selecting and
unselecting files.


File: git.info,  Node: Isearch,  Next: Input Line,  Prev: Selecting,  Up: git

Incremental searching files in a panel
--------------------------------------

   Users sometime need to search a file in a panel, especially when the
panel contains a big number of entries.  For that reason `git' provides
an incremental search feature.  Using forward and backward incremental
search, files can be very easy located.  Wrapped incremental search is
also provided.

`^S', `^Xs'
     Incremental search forward a file name in the current panel
     (`isearch-forward').  Pressing ^S or ^Xs again will
     force `git' to go to the next entry that matches the current
     isearched string.  When the end of the panel is reached, the isearch is
     restarted from its beginning.

`^R', `^Xr'
     Incremental search backward a file name in the current panel
     (`isearch-backward').  Pressing ^R or ^Xr again will
     force `git' to go to the next entry that matches the current
     isearched string.  When the beginning of the panel is reached, the
     isearch is restarted from its end.


File: git.info,  Node: Input Line,  Next: Files,  Prev: Isearch,  Up: git

Using the input line
--------------------

   The input line is one of the main methods used by `git' to interact
with the user.  All the answers the user should give in order to perform
some operation and all the shell like commands are built using it.  So
here is a description of all the basic editing operations that the
`input line' provides.  They are very much inspired from `Emacs', so
`Emacs' users should have no problem using them.

* Menu:

* Inserting Text::              Inserting text by simply typing it.
* Moving Point::                How to move the cursor to the place where you
				    want to change something.
* Erasing::                     Deleting and killing text.
* Case Changes::                Case conversion of words.
* History::                     Reusing recent input line arguments.
* Setting Mark::                Commands to set the mark.
* Yanking::                     Reinserting recently killed text.
* Selecting Files::             Selecting files matching patterns.


File: git.info,  Node: Inserting Text,  Next: Moving Point,  Up: Input Line

Inserting Text
..............

   Typing characters is the most usual way of inserting text into the
input line.  Key sequences starting with printable ascii characters are
not allowed in `git' so typing `a' for example results in inserting `a'
at the current point position.  Of course, there are some other ways of
inserting text into the command line and here there is a description of
most of them.

`ESC RET'
     Copy the current entry name into the input line at the current point
     position (`entry-to-input-line').

`ESC ESC RET'
     Copy the other panel path into the input line at the current point
     position (`other-path-to-input-line').

`^X ^I'
     Copy the names of all the selected entries into the input line at the
     current point position (`selected-entries-to-input-line').


File: git.info,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Input Line

Moving Point
............

`^B', `LEFT'
     Move the point backward one character (`backward-char').

`^F', `RIGHT'
     Move the point forward one character (`forward-char').

`ESC b'
     Move the point one word backward (`backward-word').

`ESC f'
     Move the point one word forward (`forward-word').

`^A'
     Move the cursor at the beginning of the input line (`beginning-of-line').

`^E'
     Move the cursor at the end of the input line (`end-of-line').


File: git.info,  Node: Erasing,  Next: Case Changes,  Prev: Moving Point,  Up: Input Line

Deleting and killing text
.........................

`DEL', `^D'
     Delete the character under the cursor (`delete-char').

`^H', `BKSPC'
     Delete the character before the cursor (`backward-delete-char').

`ESC BKSPC'
     Delete backward one word (`backward-kill-word').

`ESC d'
     Delete forward one word (`kill-word').

`ESC k'
     Delete the entire line (`kill-line').

`^U'
     Delete all the characters between the beginning of the input line and
     the point (`kill-to-beginning-of-line').

`^K'
     Delete all the characters between the point and the end of the input
     line (`kill-to-end-of-line').

`ESC SPC'
     Delete all the spaces around the point, leaving only one space
     (`just-one-space').

`ESC \'
     Delete all the spaces around the point
     (`delete-horizontal-space').

`^W'
     Save the region between the point and the mark into the kill "ring" and
     then kills it (`kill-region').  Note that there is no real
     kill-ring here.  The so-called kill-ring has only one entry.

`ESC w'
     Save the region between the point and the mark without killing it
     (`kill-ring-save').


File: git.info,  Node: Case Changes,  Next: History,  Prev: Erasing,  Up: Input Line

Case conversion of words.
.........................

`ESC l'
     Convert the following word to lower case, moving over.
     (`downcase-word').

`ESC u'
     Convert the following word to upper case, moving over.
     (`upcase-word').

`ESC c'
     Capitalize the following word, moving over.
     (`capitalize-word').


File: git.info,  Node: History,  Next: Setting Mark,  Prev: Case Changes,  Up: Input Line

Reusing recent input line arguments
...................................

   A separate history is kept for both built-in and user-defined
commands.  If you call a command that you have used before, you can
re-edit a previously entered string in order to minimize the amount of
characters needed to be typed for the new one.  There is no limit on
the number of strings that can be kept in the history.

`ESC p'
     Walk backward through the history of previously entered strings
     (`previous-history-element').

`ESC n'
     Walk forward through the history of previously entered strings
     (`next-history-element').


File: git.info,  Node: Setting Mark,  Next: Yanking,  Prev: History,  Up: Input Line

Commands to set the mark
........................

`^SPC'
     Set the mark at the current point position (`set-mark').

`^X ^X'
     Exchange the current point position with the mark one
     (`exchange-point-and-mark').


File: git.info,  Node: Yanking,  Next: Selecting Files,  Prev: Setting Mark,  Up: Input Line

Reinserting recently killed text
................................

`^Y'
     Reinsert a previously killed text at the current point position
     (`yank').


File: git.info,  Node: Selecting Files,  Prev: Yanking,  Up: Input Line

Selecting files matching patterns
.................................

   If the very first character in the input line is a `+', what comes
after it is considered a (space separated) list of shell patterns, and
all the files that match at least one pattern from that list will be
marked as selected.  An empty list of shell patterns (i.e. the `+' by
itself) will cause all the files to be selected.

   If the very first character in the input line is a `-', the space
separated list of shell patterns that follows is used to unselect files.
An empty list of shell patterns (i.e. the `-' by itself) will cause all
the selected files to be unselected.

   Finally, if the first and only character in the input line is a `*',
then all the selected files will become unselected, and all the
unselected files will become selected.


File: git.info,  Node: Files,  Next: Directories,  Prev: Input Line,  Up: git

File operations
---------------

* Menu:

* Copying Files::               How to copy files.
* Moving Files::                How to move files.
* Creating Files::              How to create new files.
* Deleting Files::              How to delete files.
* Linking Files::               How to create hard and symbolic links.
* Renaming Files::              How to rename files.
* Splitting Files::		How to split files into smaller parts.
* Packing Files::               How to pack files in the min. number of bins.
* Inode::                       How to change a file's mode, owner, group.

* Editing Files::               How to edit and create files.  Default editor.
* Viewing Files::               How to view files.  Default viewer.
* Compressing Files::           How to compress and decompress files.
* Encoding Files::              How to uuencode/uudecode, mpack/munpack a file.
* Encrypting Files::            How to encrypt/decrypt files with pgp.
* Comparing Files::             How to compare two files.
* Spell Checking Files::        How to spell check a file.
* Printing Files::		How to print files.
* Wiping Files::                How to wipe a file.
* Searching Files::             How to search a file.
* Archive Files::               How to manage tar based archive files.
* RPM Packages::                How to install and uninstall RPM packages.
* File Types::                  How to figure out the file type.
* MSDOS Files::                 How to access msdos floppies.

* Actions::                     A different action for each file type.


File: git.info,  Node: Copying Files,  Next: Moving Files,  Up: Files

Copying Files
.............

`F5', `ESC 5', `^C C'
     Copy the currently selected entries to the user supplied path
     (`copy').

`^C b C'
     Copy the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-COPY').


File: git.info,  Node: Moving Files,  Next: Creating Files,  Prev: Copying Files,  Up: Files

Moving Files
............

`F6', `ESC 6', `^C T'
     Move the currently selected entries to the user supplied path
     (`move').

`^C b T'
     Move the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-MOVE').


File: git.info,  Node: Creating Files,  Next: Deleting Files,  Prev: Moving Files,  Up: Files

Creating Files
..............

   The easiest way to create a new file is to start an editor passing
the file name as an argument.  Most editors will try to create the file
if the file doesn't exist.  *Note Editing Files::, for more information.


File: git.info,  Node: Deleting Files,  Next: Linking Files,  Prev: Creating Files,  Up: Files

Deleting Files
..............

`F8', `ESC 8', `^C D'
     Delete the currently selected entries (`delete').

`^C b D'
     Delete the currently selected entries.  The operation is performed in
     background (`B-DELETE').


File: git.info,  Node: Linking Files,  Next: Renaming Files,  Prev: Deleting Files,  Up: Files

Linking Files
.............

`^C H'
     Create a hard link from the current files to a user supplied file
     name (`LINK').

`^C b H'
     Create a hard link from the current files to a user supplied file name
     (`B-LINK').  The action is performed in background.

`^C S'
     Create a symbolic link from the current files to a user supplied file
     name (`SYMLINK').

`^C b S'
     Create a symbolic link from the current files to a user supplied file
     name (`B-SYMLINK').  The action is performed in background.


File: git.info,  Node: Renaming Files,  Next: Splitting Files,  Prev: Linking Files,  Up: Files

Renaming Files
..............

`^C R'
     Rename the current file or directory with the user supplied name
     (`RENAME').

`^C b R'
     Rename the current file or directory with the user supplied name.  The
     operation is performed in background (`B-RENAME').

`^C n d'
     Change the name of all the selected entries to lowercase.
     (`name-downcase').

`^C n u'
     Change the name of all the selected entries to uppercase.
     (`name-upcase').


File: git.info,  Node: Splitting Files,  Next: Packing Files,  Prev: Renaming Files,  Up: Files

Splitting files into smaller parts
..................................

`^C /'
     Split the current file into several smaller files of a given size and
     named based on a given prefix (`SPLIT').

`^C b /'
     Split the current file into several smaller files of a given size and
     named based on a given prefix.  The operation is performed in background
     (`B-SPLIT').


File: git.info,  Node: Packing Files,  Next: Inode,  Prev: Splitting Files,  Up: Files

Packing files into the minimum number of bins
.............................................

`^C ~'
     Pack the files into the smallest number of bins.  This is an
     approximation - the problem is NP-complete and no known algorithm can
     guarantee a solution better than `(11/9) * OPTIMAL + 4'.
     
     To make things even worst, it is generally difficult to figure out the
     file system block size for the target bin.  Asking the user is not a
     good idea either.  `git' currently assumes a file system block size
     of 1Kb.  Moreover, for large file, there is no portable way to predict
     how many blocks the file system implementation will require for indirect
     blocks, directories, etc.  So keep in mind that this is only an
     aproximation.
     
     Bin packing can be useful when you want to put a bunch of files on
     floppies or zip disks and you want to optimize things a little bit
     (`bin-packing').
     
     `git' assumes that you want to pack all the files in the current
     directory - if there is any selected file in that directory it will be
     unselected first.  Then `git' will ask for a bin size, and select
     the files that should go in the first bin.  You are supposed to place
     those files in the first bin (e.g. a tar archive), remove them from the
     current directory, then run `bin-packing' again, to obtain the list
     of the files that should go into the second bin, etc.


File: git.info,  Node: Inode,  Next: Editing Files,  Prev: Packing Files,  Up: Files

Changing a file's mode, owner and group
.......................................

`^C M'
     Change the mode of the currently selected entries (`CHMOD').

`^C b M'
     Change the mode of the currently selected entries.  The operation is
     performed in background (`B-CHMOD').

`^C r M'
     Recursively change the modes of the selected entries if one of them is a
     directory (`R-CHMOD').

`^C b r M'
     Recursively change the modes of the selected entries if one of them is a
     directory.  The operation is performed in background (`B-R-CHMOD').

`^C O'
     Change the owner of the currently selected entries (`CHOWN').

`^C b O'
     Change the owner of the currently selected entries.  The operation is
     performed in background (`B-CHOWN').

`^C r O'
     Recursively change the owners of the selected entries if one of them is
     a directory (`R-CHOWN').

`^C b r O'
     Recursively change the owners of the selected entries if one of them is
     a directory.  The operation is performed in background
     (`B-R-CHOWN').

`^C G'
     Change the group of the currently selected entries (`CHGRP').

`^C b G'
     Change the group of the currently selected entries.  The operation is
     performed in background (`B-CHGRP').

`^C r G'
     Recursively change the groups of the selected entries if one of them is
     a directory (`R-CHGRP').

`^C b r G'
     Recursively change the groups of the selected entries if one of them is
     a directory.  The operation is performed in background
     (`B-R-CHGRP').


File: git.info,  Node: Editing Files,  Next: Viewing Files,  Prev: Inode,  Up: Files

Editing Files
.............

`F4', `ESC 4'
     Call the default editor with the current file name as an argument
     (`EDIT').

`^X e'
     Call the default editor with the selected entry names as arguments
     (`MULTIPLE-EDIT').

`^X ^F'
     Create a new file by calling the default editor with the user supplied
     file name as an argument (`FILE-CREATE').

`^X 4 a'
     Call the default editor in order to edit the `ChangeLog' file
     (`CHANGE-LOG').

   The default editor can be specified using the EDITOR or GIT_EDITOR
environment variables.  *Note Environment Variables::, for more
information.


File: git.info,  Node: Viewing Files,  Next: Compressing Files,  Prev: Editing Files,  Up: Files

Viewing Files
.............

`F3', `ESC 3'
     Call the default viewer (`gitview') with the current file name as
     argument (`VIEW').

`^X v'
     Call the default pager (`more') with the currently selected entry
     names as arguments (`MULTIPLE-VIEW').


File: git.info,  Node: Compressing Files,  Next: Encoding Files,  Prev: Viewing Files,  Up: Files

Compressing Files
.................

`^C z'
     Compress the currently selected entries with `gzip'
     (`COMPRESS').

`^C b z'
     Compress the currently selected entries with `gzip'.  The operation
     is performed in background (`B-COMPRESS').

`^C Z'
     Uncompress the currently selected entries with `gunzip'
     (`UNCOMPRESS').

`^C b Z'
     Uncompress the currently selected entries with `gunzip'.  The
     operation is performed in background (`B-UNCOMPRESS').

`^C f Z'
     Uncompress the currently selected entries with `gunzip'
     (`F-UNCOMPRESS').  Force uncompression of links.

`^C b f Z'
     Uncompress the currently selected entries with `gunzip'.  Force
     uncompression of links.  The operation is performed in background
     (`BF-UNCOMPRESS').

`^C .'
     Compress the currently selected entries with `bzip2'
     (`BZIP2-COMPRESS').

`^C b .'
     Compress the currently selected entries with `bzip2'.  The
     operation is performed in background (`B-BZIP2-COMPRESS').

`^C o'
     Uncompress the currently selected entries with `bunzip2'
     (`BZIP2-UNCOMPRESS').

`^C b o'
     Uncompress the currently selected entries with `bunzip2'.  The
     operation is performed in background (`B-BZIP2-UNCOMPRESS').


File: git.info,  Node: Encoding Files,  Next: Encrypting Files,  Prev: Compressing Files,  Up: Files

Encoding Files
..............

`^C e'
     Encode the currently selected file (`UUENCODE').

`^C b e'
     Encode the currently selected file.  The operation is performed in
     background (`B-UUENCODE').

`^C E'
     Decode the currently selected file (`UUDECODE').

`^C b E'
     Decode the currently selected file.  The operation is performed in
     background (`B-UUDECODE').

`^C k'
     Encode the currently selected file using mpack (`MIME-PACK').

`^C b k'
     Encode the currently selected file using mpack.  The operation is
     performed in background (`B-MIME-PACK').

`^C K'
     Decode the currently selected file using munpack (`MIME-UNPACK').

`^C b K'
     Decode the currently selected file using munpack.  The operation is
     performed in background (`B-MIME-UNPACK').


File: git.info,  Node: Encrypting Files,  Next: Comparing Files,  Prev: Encoding Files,  Up: Files

Encrypting Files
................

`^C p'
     Encrypt (using `pgp') the current file (`ENCRYPT').

`^C P'
     Decrypt (using `pgp') the current file (`DECRYPT').


File: git.info,  Node: Comparing Files,  Next: Spell Checking Files,  Prev: Encrypting Files,  Up: Files

Comparing Files
...............

`^C ='
     Compare (using `diff') the current ASCII file with the other
     panel's current file (`DIFF').  If both entries are directories, a
     recursive diff is performed.

`^C ESC ='
     Compare (using `diff') the current ASCII file with its latest
     backup.  The latest backup is the file having the same name and a '~' at
     the end (`LAST-BACKUP-DIFF').

`^C B'
     Compare the current file with the other panel current file.  A binary
     comparison is performed (`compare').


File: git.info,  Node: Spell Checking Files,  Next: Printing Files,  Prev: Comparing Files,  Up: Files

Spell Checking Files
....................

`^X I'
     Run the `ispell' command with the current file name as an
     argument.


File: git.info,  Node: Printing Files,  Next: Wiping Files,  Prev: Spell Checking Files,  Up: Files

Printing Files
..............

`^C j'
     Print the selected files via `lpr' to the user specified printer or
     to the default one if no `lpr' options are given (`PRINT-JOB').

`^C J'
     Print the list of active printing jobs via `lpq'.  The default
     printer is queried if no `lpq' options are given
     (`PRINT-JOB-LIST').


File: git.info,  Node: Wiping Files,  Next: Searching Files,  Prev: Printing Files,  Up: Files

Wiping Files
............

`^C W'
     Call `gitwipe' to wipe the selected files.  Asks for confirmation
     before actually wiping them in order to avoid errors (`WIPE').
   *Note gitwipe::, for more information.


File: git.info,  Node: Searching Files,  Next: Archive Files,  Prev: Wiping Files,  Up: Files

Searching Files
...............

`ESC %'
     Searche files on the file system, starting from the current directory
     (`FIND').

`ESC &'
     Use 'locate' to search files on the file system, starting from the
     current directory (`LOCATE').

`^X w'
     Locate the binary, source, and manual page files for a command
     (`WHEREIS').

`^X W'
     Locate a command; display its pathname or alias (`WHICH').


File: git.info,  Node: Archive Files,  Next: RPM Packages,  Prev: Searching Files,  Up: Files

Managing tar based archive files
................................

`^C a'
     Create a `tar' archive containing all the currently selected
     entries (`TAR').

`^C b a'
     Create a `tar' archive containing all the currently selected
     entries.  The operation is performed in background (`B-TAR').

`^C x'
     Create a compressed `tar' archive containing the current entry,
     provided it is a directory (`TAR-COMPRESS').

`^C b x'
     Create a compressed `tar' archive containing the current entry,
     provided it is directory.  The operation is performed in background
     (`B-TAR-COMPRESS').

`^C -'
     Create a bzip2 compressed `tar' archive containing the current
     entry, provided it is a directory (`TAR-BZIP2').

`^C b -'
     Create a bzip2 compressed `tar' archive containing the current
     entry, provided it is a directory.  The operation is performed in
     background (`B-TAR-BZIP2').

`^C X'
     Expand the selected archives into the current directory.  The utility
     used is selected based on the extension of the file
     (`GENERIC-UNPACK').

`^C b X'
     Expand the selected archives into the current directory.  The utility
     used is based on the extension of the file.  The operation is performed
     in background (`B-GENERIC-UNPACK').

`^C V'
     Expand the selected archives into an user supplied current directory.
     The utility used is selected based on the extension of the file
     (`GENERIC-UNPACK-INTO').

`^C b V'
     Expand the selected archives into an user supplied directory.  The
     utility used is based on the extension of the file.  The operation is
     performed in background (`B-GENERIC-UNPACK-INTO').


File: git.info,  Node: RPM Packages,  Next: File Types,  Prev: Archive Files,  Up: Files

Installing and Uninstalling RPM packages
........................................

   Red Hat Linux Distributions use a very powerful package manager
called `rpm'.  It is used whenever you need to
install/remove/upgrade/etc a software package.  The packages used by
`rpm' use the extension `.rpm'.  `git' provides default key bindings
for some of the basic operations `rpm' can perform on packages:
install, uninstall, upgrade and query.

`^C I'
     Install the `rpm' package pointed by the cursor
     (`RPM-INSTALL').

`^C b I'
     Install the `rpm' package pointed by the cursor
     (`B-RPM-INSTALL').  The operation is performed in background.

`^C i'
     Uninstall the `rpm' package pointed by the cursor
     (`RPM-UNINSTALL').

`^C b i'
     Uninstall the `rpm' package pointed by the cursor
     (`B-RPM-UNINSTALL').  The operation is performed in background.

`^C N'
     Upgrade the `rpm' package pointed by the cursor
     (`RPM-UPGRADE').

`^C b N'
     Upgrade the `rpm' package pointed by the cursor
     (`B-RPM-UPGRADE').  The operation is performed in background.

`^C q'
     Query the `rpm' package manager (`RPM-QUERY').  The default
     options used are `-qil'.  See the `rpm' manual page for
     more details on using `rpm'.


File: git.info,  Node: File Types,  Next: MSDOS Files,  Prev: RPM Packages,  Up: Files

File Types
..........

`^C t'
     Print the type of a file using the `file' utility
     (`FILE-TYPE').


File: git.info,  Node: MSDOS Files,  Next: Actions,  Prev: File Types,  Up: Files

Accessing MSDOS Files
.....................

`^C m d', `^C m ^D'
     Change the current `MSDOS' directory to a given directory
     (`MTOOLS-CHDIR').

`^C m P'
     Put the currently selected files on a `MSDOS' floppy
     (`MTOOLS-PUT').

`^C b m P'
     Put the currently selected files on a `MSDOS' floppy
     (`B-MTOOLS-PUT').  The operation is performed in background.

`^C m G'
     Get some files from a `MSDOS' floppy and put them in a given
     directory (`MTOOLS-GET').

`^C b m G'
     Get some files from a `MSDOS' floppy and put them in a given
     directory (`B-MTOOLS-GET').  The operation is performed in
     background.

`^C m D'
     Delete files from a `MSDOS' floppy (`MTOOLS-DELETE').

`^C b m D'
     Delete files from a `MSDOS' floppy (`B-MTOOLS-DELETE').  The
     operation is performed in background.

`^C m L'
     List files and directories on a `MSDOS' floppy (`MTOOLS-DIR').

`^C m F'
     Format a `MSDOS' floppy (`MTOOLS-FORMAT').

`^C b m F'
     Format a `MSDOS' floppy (`B-MTOOLS-FORMAT').  The operation is
     performed in background.

`^C m M'
     Create a directory on a `MSDOS' floppy (`MTOOLS-MKDIR').

`^C b m M'
     Create a directory on a `MSDOS' floppy (`B-MTOOLS-MKDIR').
     The operation is performed in background.

`^C m K'
     Remove a directory from a `MSDOS' floppy (`MTOOLS-RMDIR').
     All the files and subdirectories in that directory are removed as well.

`^C b m K'
     Remove a directory from a `MSDOS' floppy (`B-MTOOLS-RMDIR').
     All the files and subdirectories in that directory are removed as well.
     The operation is performed in background.

`^C m R'
     Rename a file or directory on a `MSDOS' floppy
     (`MTOOLS-RENAME').

`^C b m R'
     Rename a file or directory on a `MSDOS' floppy
     (`B-MTOOLS-RENAME').  The operation is performed in background.

`^C m T'
     Display the contents of a file located on a `MSDOS' floppy
     (`MTOOLS-TYPE').


File: git.info,  Node: Actions,  Prev: MSDOS Files,  Up: Files

A different action for each file type
.....................................

   Many files on `UNIX' systems have one or more extensions specifying
their types.  For example, a file that ends in `.c' is a file
containing a `C' program, while a file ending in `.tar.gz' is a `tar'
archive compressed with the `gzip' utility.  Having a default action
for each file type, binded on the same key, seems to be a good idea
because you can use that key to obtain type specific information about
a file or to process it in some type specific way much easier.  The
`GIT' package contains a script called `gitaction' that is used to
detect the current file type and perform a type specific action.  *Note
gitaction::, for more information.

`F2', `ESC 2', `^X a'
     Perform an action on the current file, depending on its type
     (`FILE-ACTION').


File: git.info,  Node: Directories,  Next: Compiling,  Prev: Files,  Up: git

Directory operations
--------------------

* Menu:

* Creating Dirs::               How to create new directories.
* Copying Dirs::                How to copy directories.
* Deleting Dirs::               How to delete directories.
* Moving Dirs::                 How to move directories.
* Renaming Dirs::               How to rename directories.
* Comparing Dirs::              How to compare directories.
* Dirs Usage::                  Summarize directory usage.
* Changing Dirs::               How to go to a new directory.
* Dirs History::                How to use the directory history.
* Hot Keys::                    Hot keys for the most used directories.


File: git.info,  Node: Creating Dirs,  Next: Copying Dirs,  Up: Directories

Creating directories
....................

`F7', `ESC 7', `^X M'
     Create a new subdirectory in the current directory with the user
     supplied name (`make-directory').


File: git.info,  Node: Copying Dirs,  Next: Deleting Dirs,  Prev: Creating Dirs,  Up: Directories

Copying directories
...................

`F5 (for directories)', `ESC 5 (for directories)', `^C C (for
directories)'
     Copy the currently selected entries to the user supplied path
     (`copy').

`^C b C (for directories)'
     Copy the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-COPY').


File: git.info,  Node: Deleting Dirs,  Next: Moving Dirs,  Prev: Copying Dirs,  Up: Directories

Deleting directories
....................

`F8 (for subdirectories)', `ESC 8 (for directories)', `^C D (for
subdirectories)'
     Delete the currently selected entries (`delete').

`^C b D (for directories)'
     Delete the currently selected entries.  The operation is performed in
     background (`B-DELETE').


File: git.info,  Node: Moving Dirs,  Next: Renaming Dirs,  Prev: Deleting Dirs,  Up: Directories

Moving directories
..................

`F6 (for directories)', `ESC 6 (for directories)', `^C T (for
directories)'
     Move the currently selected entries to the user supplied path
     (`move').

`^C b T (for directories)'
     Move the currently selected entries to the user supplied path.  The
     operation is performed in background (`B-MOVE').


File: git.info,  Node: Renaming Dirs,  Next: Comparing Dirs,  Prev: Moving Dirs,  Up: Directories

Renaming directories
....................

`^C R (for directories)'
     Rename the current file or directory with the user supplied name
     (`RENAME').

`^C b R (for directories)'
     Rename the current file or directory with the user supplied name.  The
     operation is performed in background (`B-RENAME').


File: git.info,  Node: Comparing Dirs,  Next: Dirs Usage,  Prev: Renaming Dirs,  Up: Directories

Comparing Directories
.....................

`^C c q'
     Quickly compare the files in the left panel with the files in the right
     one.  Only the file names, sizes and time stamps are considered in the
     comparison.

`^C c t'
     Compare the files in the left panel with the files in the right one.
     The contents of each file in the current panel will be compared against
     the contents of its couterpart (if any) from the other panel.

`^C f d'
     Recursively compare (using `diff -r -q') the current directory with
     the other panel's current directory (`FAST-DIFF').  Print on
     standard output the names of the files that differ.

`^C d'
     Compare (using `diff') the current directory with the other panel
     current directory.  For successful operation, both panels should contain
     the same directory (`DIR-DIFF').

`^C b d'
     Compare (using `diff') the current directory with the other panel
     current directory.  For successful operation, both panels should contain
     the same directory.  The operation is performed in background
     (`DIR-DIFF').


File: git.info,  Node: Dirs Usage,  Next: Changing Dirs,  Prev: Comparing Dirs,  Up: Directories

Summarize directory usage
.........................

`^C U'
     Display the output of the `du -s' command on the status line
     (`DIRECTORY-USAGE').


File: git.info,  Node: Changing Dirs,  Next: Dirs History,  Prev: Dirs Usage,  Up: Directories

Changing directories
....................

`^X d', `^X ^D'
     Change the current working directory.  The user is asked for a new
     directory name and the new directory is added to the directory history
     (`change-directory').
   *Note Dirs History::, for more information.

`ESC a c'
     Change the current directory of the current panel to the directory of
     the other panel (`adapt-current-directory').

`ESC a o'
     Change the current directory of the other panel to the directory of the
     current panel (`adapt-other-directory').


File: git.info,  Node: Dirs History,  Next: Hot Keys,  Prev: Changing Dirs,  Up: Directories

Directory History
.................

   Users usually work on a limited set of subdirectories.  Providing a
fast method of switching between a number of intensively used
directories is a good idea and `git' has a set of builtin commands for
doing it.

   Usually new directories are added to the directory history when the
`change-directory' built-in command is used.  `git' also adds the
current directory to the history list when started, when the directory
history is reseted and when a command having a non empty `new-dir'
field successfully completes its execution.  *Note new-dir::, for more
information.

`^X ^N'
     Go to the next directory in the history (`next-directory').

`^X ^P'
     Go to the previous directory in the history
     (`previous-directory').

`^X ^R'
     Reset the entire directory history.  As explained above, the current
     directory becomes the only directory in the history
     (`reset-directory-history').

